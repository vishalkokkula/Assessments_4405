# -*- coding: utf-8 -*-
"""customer segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gws3fVxq6f06PEzE6dzh8DLdKXVO5g7i
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler,StandardScaler,LabelEncoder
from sklearn.model_selection import train_test_split

from sklearn.cluster import KMeans

"""# load data"""

pd.set_option('display.max_columns', None)
df = pd.read_csv('/content/customer_segmentation.csv')
df

"""#Data pre processing"""

df.info()

df.isnull().sum()

df['Income']=df['Income'].fillna(df['Income'].mean())

df.isnull().sum()

df.duplicated().sum()

def outliers_iqr(df):
    q1 = np.percentile(df, 25)
    q3 = np.percentile(df, 75)
    iqr = q3 - q1
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    outliers = [x for x in df if x < lower_bound or x > upper_bound]
    return outliers
numerical_columns = df.select_dtypes(include=[np.number])
outliers_dict = {}
for col in numerical_columns.columns:
    outliers_dict[col] = outliers_iqr(df[col])
for col, outliers in outliers_dict.items():
    print("Outliers in column '{}': {}".format(col, outliers))

"""#EDA"""

df.shape

#correlation blw numerical colns:

numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns
correlation_matrix = df[numerical_columns].corr()
print(correlation_matrix)

#heat map
plt.figure(figsize=(20, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm')
plt.title('Heatmap of Correlation Matrix')
plt.show()

# scatter
# numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns
# for i in range(len(numerical_columns)):
#     for j in range(i + 1, len(numerical_columns)):
#         plt.figure(figsize=(10, 6))
#         #sns.scatterplot(data=df, x=numerical_columns[i], y=numerical_columns[j])
#         plt.title(f'Scatter Plot between {numerical_columns[i]} and {numerical_columns[j]}')
#         #plt.show()

"""# model training and testing"""

df.head()

df.columns

# encoding
encoder = LabelEncoder()
cols =['Year_Birth', 'Education', 'Marital_Status','Dt_Customer']
for col in cols:
  df[col]= encoder.fit_transform(df[col])

# data sampling
columns_for_clustering = ['NumDealsPurchases', 'NumWebPurchases',
       'NumCatalogPurchases', 'NumStorePurchases', 'NumWebVisitsMonth']

X = df[columns_for_clustering]

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# elbow method
wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, init='k-means++', random_state=42)
    kmeans.fit(X_scaled)
    wcss.append(kmeans.inertia_)

plt.figure(figsize=(10, 6))
plt.plot(range(1, 11), wcss, marker='o', linestyle='--')
plt.title('Elbow Method')
plt.xlabel('Number of Clusters')
plt.ylabel('WCSS')
plt.xticks(range(1, 11))
plt.grid(True)
plt.show()

# clustering
n_clusters = 3
kmeans = KMeans(n_clusters=n_clusters, init='k-means++', random_state=42)
kmeans.fit(X_scaled)

df['Cluster'] = kmeans.labels_
print("\nClustered Dataset:")



pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

centroids = kmeans.cluster_centers_
centroids_pca = pca.transform(centroids)
plt.figure(figsize=(10, 6))
for cluster in range(n_clusters):
    plt.scatter(X_pca[df['Cluster'] == cluster, 0], X_pca[df['Cluster'] == cluster, 1], label=f'Cluster {cluster}')
plt.scatter(centroids_pca[:, 0], centroids_pca[:, 1], color='purple', marker='*', label='Centroid')
plt.title('Clustering of Countries (PCA)')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.legend()
plt.grid(True)
plt.show()

"""# metrics"""

#silhouette_score
from sklearn.metrics import silhouette_score
sse = []
sil_score=[]
k_nrg=range(1,10)
for k in range(1,10):
   kmeans = KMeans(n_clusters=k)
   kmeans.fit(df)
   sse.append(kmeans.inertia_)
   if k>=2:
    x=silhouette_score(df, kmeans.fit_predict(df))
    sil_score.append(x)
plt.xlabel('K')
plt.ylabel('Sum of squared error')
plt.plot(sse)
plt.show()
plt.xlabel('K')
plt.ylabel('Silhouette Score')
plt.plot(range(2,10),sil_score,color='red')
plt.show()